Don't Miss the Big Picture: When studying data structures and algorithms, it's important to 
grasp the overall concept and purpose behind them. Understand how they fit into the larger 
context of problem-solving and algorithmic design.

Don't be a Passive Reader: Actively engage with the material. Experiment with code examples, 
work through problem-solving exercises, and try to implement the data structures and 
algorithms yourself. By doing so, you'll gain a deeper understanding and internalize 
the concepts.

Don't Read Too Fast: Take your time to digest and comprehend the intricacies of data structures 
and algorithms. Rushing through the material may lead to misunderstandings or missed insights. 
Be patient and give yourself enough time to absorb the concepts thoroughly.

Make the Idea Your Own: Instead of just memorizing formulas or implementations, strive to 
understand the underlying principles and reasoning behind data structures and algorithms. Try to 
explain them in your own words, implement them from scratch, and apply them to real-world problems. 
This active involvement will solidify your understanding and make the ideas truly your own.

By applying these principles, you can develop a stronger comprehension of data structures and 
algorithms, just as the article suggests for reading mathematics. It's all about actively engaging 
with the material, understanding the big picture, and making the concepts your own through practice 
and reflection.

//////////////////////////////////////////////////////////////

DSA History 
Prehistoric times: Arrays (Basic concept of contiguous memory storage)
1736: Graphs (Explored and formalized by Euler)
1940s: Depth-First Search (DFS) (Developed and attributed to Charles Pierre Tr√©maux)
1940s: Breadth-First Search (BFS) (Invented by Konrad Zuse)
1940s: Queue (Invented by Alan Turing)
1945: Merge Sort (Invented by John von Neumann)
1956: Dijkstra's Algorithm (Invented by Edsger Dijkstra)
1956: Kruskal's Algorithm (Proposed by Joseph Kruskal)
1957: Prim's Algorithm (Invented by Robert C. Prim)
1959: Quicksort (Invented by Tony Hoare)
1960s: Binary Search Tree (Invented by Adelson-Velsky and Landis, also known as AVL)
1960s: Hash Table (Invented by Donald D. Knuth)
1960s: Linked List (Invented by Allen Newell and Herbert A. Simon)
1960s: Stack (Invented by Charles Leonard Hamblin)
1962: Radix Sort (Developed by Harold H. Seward)
1962: Floyd-Warshall Algorithm (Invented by Robert Floyd and Stephen Warshall)
1962: AVL Tree (Invented by Adelson-Velsky and Landis)
1964: Binary Heap (Introduced by J.W.J. Williams)
1964: Heap (Invented by J.W.J. Williams)
1972: Red-Black Tree (Invented by Rudolf Bayer and Ed McCreight)
1977: Boyer-Moore Algorithm (Invented by Robert S. Boyer and J Strother Moore)
1960s-1970s: Knapsack Problem (Explored by Tobias Dantzig and Bernard Koopman)
1960s-1970s: Trie (Invented by Edward Fredkin)
1960s-1970s: Topological Sorting (Explored by C.A.R. Hoare and investigated by Donald Knuth)
Late 1960s: A* Search Algorithm (Invented by Peter Hart, Nils Nilsson, and Bertram Raphael)
1950s-1970s: Bellman-Ford Algorithm (Invented by Richard Bellman and Lester Ford Jr.)

Array: Introduced by John von Neumann in 1945. The concept of arrays as a 
built-in data structure was later implemented in programming languages like 
Fortran, which was developed in the 1950s for scientific and 
engineering computations.

Linked List: Introduced in 1955-1956 by Allen Newell, Cliff Shaw, and 
Herbert A. Simon at RAND Corporation and Carnegie Mellon University as 
part of their Information Processing Language (IPL) for developing 
artificial intelligence programs.

Stack: The concept of a stack has been known for a long time, but the 
implementation in programming languages can be attributed to the language 
Algol 60, developed in the late 1950s. Algol 60 introduced the stack as a 
fundamental data structure for subroutine calls and local variables.

Queue: The concept of a queue was introduced in the 1940s by Konrad Zuse, 
a German civil engineer and computer pioneer. The concept was further 
developed and popularized by the programming language Algol 68 in the 
late 1960s.

Binary Tree: The concept of binary trees has been known for a long time, but 
the first systematic analysis of binary trees was conducted by 
Gustav T. A. Meijer in 1951. The programming language Algol 60 provided the 
necessary language constructs for working with binary trees.

Heap: The concept of heaps dates back to the work of J. W. J. Williams 
in 1964. The programming language Algol 68 introduced the heap data structure 
as a fundamental tool for dynamic memory allocation and management.

Hash Table: The concept of hash tables can be attributed to the language 
FORTRAN IV, which was developed in the 1960s. Hash tables were used to implement 
associative arrays, allowing efficient lookup and storage of key-value pairs.

Graph: While graphs have been studied in mathematics for centuries, the field of 
graph theory gained prominence in the 18th and 19th centuries with contributions 
from Euler, Hamilton, and others. One of the earliest instances of graph data 
structures being implemented in computer science was in the programming language 
ALGOL 68 (developed in the late 1960s), provided built-in language 
constructs for working with graphs. 

Trie: The concept of the trie, or prefix tree, was introduced by Edward Fredkin 
in 1960. It was later popularized by the programming language PL/I, which provided 
native support for trie data structures.

Red-Black Tree: Introduced by Rudolf Bayer and Ed McCreight in 1972, the red-black 
tree is a self-balancing binary search tree. Although it is not directly associated 
with a specific programming language, it gained recognition and widespread use in 
various languages due to its balanced nature, providing efficient search, insert, 
and delete operations.

AVL Tree: The AVL tree was invented by Georgy Adelson-Velsky and Evgenii Landis 
in 1962. It was named after the inventors (AVL stands for their initials) and was 
designed to maintain a balanced binary search tree. The AVL tree was initially 
implemented in ALGOL, a high-level programming language, and its self-balancing 
property ensures efficient operations even with dynamic data.

Please note that the list represents a general overview, and there may be variations 
and earlier instances of these data structures that are not specifically mentioned.

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

Grokking the Coding Interview Patterns

Denotes the problem also appears in the Grind75 list.

Sliding Window Pattern:

- Maximum Sum Subarray of Size K (LC 53)*
- Longest Substring with K Distinct Characters (LC 340)
- Smallest Subarray with a Given Sum (LC 209)

Two Pointers Pattern:

- Pair with Target Sum (LC 1)*
- Remove Duplicates from Sorted Array (LC 26)*
- Squares of a Sorted Array (LC 977)

Fast and Slow Pointers Pattern:

- LinkedList Cycle (LC 141)*
- Middle of the Linked List (LC 876)
- Linked List Cycle II (LC 142)

Merge Intervals Pattern:

- Merge Intervals (LC 56)*
- Insert Interval (LC 57)*
- Intervals Intersection (LC 986)

Cyclic Sort Pattern:

- Cyclic Sort (LC 287)*
- Find the Missing Number (LC 268)*
- Find All Missing Numbers (LC 448)

In-place Reversal of a LinkedList Pattern:

- Reverse a LinkedList (LC 206)*
- Reverse Sublist (LC 92)
- Reverse Nodes in k-Group (LC 25)

Tree Breadth First Search Pattern:

- Binary Tree Level Order Traversal (LC 102)*
- Zigzag Level Order Traversal (LC 103)
- Minimum Depth of Binary Tree (LC 111)

Tree Depth First Search Pattern:

- Binary Tree Path Sum (LC 112)*
- All Paths from Source to Target (LC 797)
- Sum Root to Leaf Numbers (LC 129)

Two Heaps Pattern:

- Find Median from Data Stream (LC 295)
- Sliding Window Median (LC 480)*
- Kth Smallest Element in a Sorted Matrix (LC 378)

Subsets Pattern:

- Subsets (LC 78)*
- Subsets II (LC 90)
- Permutations (LC 46)

Modified Binary Search Pattern:

- Binary Search (LC 704)*
- Find Smallest Letter Greater Than Target (LC 744)
- Search in Rotated Sorted Array (LC 33)

Top 'K' Elements Pattern:

- Top K Frequent Elements (LC 347)*
- Kth Largest Element in an Array (LC 215)*
- K Closest Points to Origin (LC 973)

K-way Merge Pattern:

- Merge K Sorted Lists (LC 23)*
- Kth Smallest Element in a Sorted Matrix (LC 378)*
- Find K Pairs with Smallest Sums (LC 373)

0/1 Knapsack (Dynamic Programming) Pattern:

- 0/1 Knapsack (LC 474)*
- Target Sum (LC 494)
- Partition Equal Subset Sum (LC 416)

Topological Sort Pattern:

- Course Schedule (LC 207)*
- Alien Dictionary (LC 269)*
- Sequence Reconstruction (LC 444)

Minimize 'Max' Difference Pattern:

- Capacity To Ship Packages Within D Days (LC 1011)
- Split Array Largest Sum (LC 410)*
- Koko Eating Bananas (LC 875)

Interval Merge Pattern:

- Merge Intervals (LC 56)*
- Insert Interval (LC 57)*
- Non-overlapping Intervals (LC 435)*

Palindromic Subsequence Pattern:

- Longest Palindromic Subsequence (LC 516)*
- Longest Palindromic Substring (LC 5)*
- Count Different Palindromic Subsequences (LC 730)*














